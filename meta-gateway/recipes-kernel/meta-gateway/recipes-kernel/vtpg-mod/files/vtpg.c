/*
 * vtpg kernel module driver for vtpg IP.
 *
 * Copyright 2008 - 2013 Xilinx, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * as published by the Free Software Foundation.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
//#define DEBUG

#include <linux/bitops.h>
#include <linux/init.h>
#include <linux/errno.h>
#include <linux/module.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>
#include <linux/interrupt.h>
#include <linux/io.h>
#include <linux/slab.h>
#include <linux/pm_runtime.h>
#include <linux/clk.h>
#include <linux/fs.h>//For file operations structure
#include <linux/cdev.h>

#include "xv_tpg_hw.h"

//--------------------------------Notes------------------------------------
//Xilinx TPG IP v7.0 is an HLS IP; TPG v7.0 does not have interrupts connected
//Alternative to custom driver: v4l2 driver + xilinx tpg driver

//------------------------Constants---------------------------------------
#define DRIVER_NAME "vtpg_driver"
//#define V_TPG_BASE_ADDR	0x43C00000
//From xil_types.h generated by Xilinx
#define XIL_COMPONENT_IS_READY 0x11111111U //for verification
//#define XIL_COMPONENT_IS_STARTED 0x22222222U

//-------------------------Macros---------------------------------------
/* Read/Write access to IP registers */
#if defined(CONFIG_ARCH_ZYNQ) || defined(CONFIG_ARM64)
# define vtpg_readreg(offset)		readl(offset)
# define vtpg_writereg(offset, val)	writel(val, offset)
#else
# define vtpg_readreg(offset)		__raw_readl(offset)
# define vtpg_writereg(offset, val)	__raw_writel(val, offset)
#endif

//-------------------------Globals------------------------------------

struct vtpg_instance {
	u16 DeviceId;
	//void __iomem *s_axi_ctrl_base_address;
	u32 s_axi_ctrl_base_address;
	u32 s_axi_ctrl_addr_width;
	u32 s_axi_ctrl_data_width;
	u32 max_height;
	u32 max_width;
	u32 ppc;
	u32 IsReady;
	//Character device members
	dev_t dev_node;
	struct device *vtpg_device;
	struct cdev cdev;
	struct class *class_vtpg;
	//--------------------------------
	struct clk *clk;
};
//---------------------------------------------------------------------------------------
//-------Character device functions

static int vtpg_local_open(struct inode *ino, struct file *file)
{
	file->private_data = container_of(ino->i_cdev, struct vtpg_instance, cdev);
	printk("Device open\n");
	return 0;
}
static int vtpg_release(struct inode *ino, struct file *file)
{
	printk("Device closed\n");
	return 0;
}

static ssize_t vtpg_write(struct file *fileptr, const char *buf, size_t count, loff_t *f_pos){
	printk("Writing to device ...\n");
	return 1;
}

static ssize_t vtpg_read(struct file *fileptr, char *buf, size_t count, loff_t *f_pos){
	printk("Reading from device ...\n");
	return 1;
}

static long vtpg_ioctl(struct file *file, unsigned int unused , unsigned long arg)
{
	printk("IOCTL call\n");
	return 0;
}
static struct file_operations vtpg_fops = {
	.owner    = THIS_MODULE,
	.open     = vtpg_local_open,
	.read     = vtpg_read,
	.write     = vtpg_write,
	.release  = vtpg_release,
	.unlocked_ioctl = vtpg_ioctl,
};

//static struct class *class_vtpg;

static int cdevice_init(struct vtpg_instance *TPG_IP)
{
	int status;
	char device_name[32] = "vtpg";
	struct device *subdev;
	
	status=0;

	/* Allocate a character device from the kernel for this driver.
	 */
	status = alloc_chrdev_region(&TPG_IP->dev_node, 0, 1, "vtpg");

	if (status) {
		dev_err(TPG_IP->vtpg_device, "unable to get a char device number\n");
		//pr_err("unable to get a char device number\n");
		return status;
	}

	/* Initialize the device data structure before registering the character 
	 * device with the kernel.
	 */
	cdev_init(&TPG_IP->cdev, &vtpg_fops);
	TPG_IP->cdev.owner = THIS_MODULE;
	status = cdev_add(&TPG_IP->cdev, TPG_IP->dev_node, 1);

	if (status) {
		dev_err(TPG_IP->vtpg_device, "unable to add char device\n");
		goto init_error1;
	}
	
	pr_info("Creating vtpg class...\n");
	/* Only one class in sysfs is to be created for multiple channels,
	 * create the device in sysfs which will allow the device node
	 * in /dev to be created
	 */
	TPG_IP->class_vtpg = class_create(THIS_MODULE, DRIVER_NAME);
	pr_info("class_create function called...\n");

	if (IS_ERR(TPG_IP->class_vtpg)) {
		dev_err(TPG_IP->vtpg_device, "unable to create class\n");
		status = -1;
		goto init_error2;
	}
	pr_info("Initialising vtpg class...\n");

	/* Create the device node in /dev so the device is accessible
	 * as a character device
	 */
	//struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)
	subdev = device_create(TPG_IP->class_vtpg, TPG_IP->vtpg_device,
					  	 TPG_IP->dev_node, NULL, device_name);

	if (IS_ERR(subdev)) {
		dev_err(TPG_IP->vtpg_device, "unable to create the device\n");
		goto init_error3;
	}

	return 0;

init_error3:
	class_destroy(TPG_IP->class_vtpg);

init_error2:
	cdev_del(&TPG_IP->cdev);

init_error1:
	unregister_chrdev_region(TPG_IP->dev_node, 1);
	return status;
}

/* Exit the character device by freeing up the resources that it created and
 * disconnecting itself from the kernel.
 */
static void cdevice_exit(struct vtpg_instance *TPG_IP)
{
	/* Take everything down in the reverse order
	 * from how it was created for the char device
	 */
	device_destroy(TPG_IP->class_vtpg, TPG_IP->dev_node);
	class_destroy(TPG_IP->class_vtpg);

	cdev_del(&TPG_IP->cdev);
	unregister_chrdev_region(TPG_IP->dev_node, 1);
}
//---------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------
//-------Platform device functions

static int vtpg_remove(struct platform_device *pdev)
{
	struct vtpg_instance *TPG_IP;
	pm_runtime_disable(&pdev->dev);
	TPG_IP = platform_get_drvdata(pdev);
	cdevice_exit(TPG_IP);
	printk("Removing...\n");
	return 0;
}

static int vtpg_probe(struct platform_device *pdev)
{
	//int irq; 
	u32 tmp;
	struct device_node *np;
	struct vtpg_instance *TPG_IP;
	int status;
	struct resource *res;

	printk("Probing...\n");
	np = pdev->dev.of_node;
	status = 0;

	//Driver data memory allocation-----------------------
	TPG_IP = devm_kzalloc(&pdev->dev, sizeof(*TPG_IP), GFP_KERNEL);
	//devm_kzalloc() initialises allocated memory with zeros, memory freed automatically
	if (!TPG_IP){
		dev_err(&pdev->dev, "Could not allocate memory for vtpg device\n");
		return -ENOMEM;
	}
	else printk("Memory allocated for TPG IP at 0x%p\n", TPG_IP);
	//----------------------Set device data------------------------------
	of_property_read_u32(np, "xlnx,s-axi-ctrl-addr-width", &TPG_IP->s_axi_ctrl_base_address);
	of_property_read_u32(np, "xlnx,s-axi-ctrl-data-width", &TPG_IP->s_axi_ctrl_data_width);
	of_property_read_u32(np, "xlnx,ppc", &TPG_IP->ppc);// pixels per clock
	of_property_read_u32(np, "xlnx,max-width", &TPG_IP->max_width);
	of_property_read_u32(np, "xlnx,max-height", &TPG_IP->max_height);
	TPG_IP->DeviceId = 0;
	TPG_IP->IsReady = XIL_COMPONENT_IS_READY;
	
	platform_set_drvdata(pdev, TPG_IP);//Sets driver data
	
	TPG_IP->clk = devm_clk_get(&pdev->dev, "ap_clk");
	if (IS_ERR(TPG_IP->clk)) {
		if (PTR_ERR(TPG_IP->clk) != -ENOENT) {
			dev_err(&pdev->dev, "Input clock not found\n");
			return PTR_ERR(TPG_IP->clk);
		}

		/*
		 * Clock framework support is optional, continue on
		 * anyways if we don't find a matching clock.
		 */
		TPG_IP->clk = NULL;
	}

	status = clk_prepare(TPG_IP->clk);
	if (status < 0) {
		dev_err(&pdev->dev, "Failed to preapre clk\n");
		return status;
	}
	pm_runtime_enable(&pdev->dev);
	status = pm_runtime_get_sync(&pdev->dev);
	if (status < 0)
		goto err_unprepare_clk;
	//Set up memory to allow device access, map physical memory into virtual address space
	printk("Mapping physical memory ...\n");
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	TPG_IP->s_axi_ctrl_base_address = devm_ioremap_resource(&pdev->dev, res);
	if (IS_ERR(TPG_IP->s_axi_ctrl_base_address)){
		dev_err(&pdev->dev, "Could not map physical memory  to virtual memory for vtpg device\n");
		return PTR_ERR(TPG_IP->s_axi_ctrl_base_address);
	}
	else printk("Physical memory at 0x%p mapped to 0x%p\n", (void *)res->start, (void *)TPG_IP->s_axi_ctrl_base_address);

	pr_info("vtpg: %s: registered\n", np->full_name);
	//----------Starting device------------------------

	pr_info("Setting height...\n");
	vtpg_writereg(TPG_IP->s_axi_ctrl_base_address + XV_TPG_CTRL_ADDR_HEIGHT_DATA, 1080);

	pr_info("Setting width...\n");
	vtpg_writereg(TPG_IP->s_axi_ctrl_base_address + XV_TPG_CTRL_ADDR_WIDTH_DATA, 1920);

	pr_info("Setting colour format...\n");//RGB
	vtpg_writereg(TPG_IP->s_axi_ctrl_base_address + XV_TPG_CTRL_ADDR_COLORFORMAT_DATA, 0x0);

	pr_info("Setting background ID...\n");//colour bars
	vtpg_writereg(TPG_IP->s_axi_ctrl_base_address + XV_TPG_CTRL_ADDR_BCKGNDID_DATA, 0x9);

	pr_info("Enable autorestart...\n");
	vtpg_writereg(TPG_IP->s_axi_ctrl_base_address + XV_TPG_CTRL_ADDR_AP_CTRL, 0x80);

	pr_info("Starting device...\n");//Ensure auto restart
	tmp=(vtpg_readreg(TPG_IP->s_axi_ctrl_base_address + XV_TPG_CTRL_ADDR_AP_CTRL)) & 0x80;
	vtpg_writereg(TPG_IP->s_axi_ctrl_base_address + XV_TPG_CTRL_ADDR_AP_CTRL, tmp|0x1);//set ap_start=1

//	pr_info("Device idle? : ");
//	tmp=vtpg_readreg(TPG_IP->s_axi_ctrl_base_address + XV_TPG_CTRL_ADDR_AP_CTRL);
//	tmp=(tmp >> 2) & 0x1;
//	pr_info("%d \n", tmp);

	tmp=vtpg_readreg(TPG_IP->s_axi_ctrl_base_address + XV_TPG_CTRL_ADDR_AP_CTRL);
	pr_info("Ctrl reg : %d\n", tmp);

	//-------------------------------
	status = cdevice_init(TPG_IP);
	if (status) {
		pr_err("Error at char device init\n");
		return status;
	}

	pm_runtime_put(&pdev->dev);
	return 0;

err_pm_put:
	pm_runtime_put(&pdev->dev);
err_unprepare_clk:
	pm_runtime_disable(&pdev->dev);
	clk_unprepare(TPG_IP->clk);
	return status;
}

static const struct of_device_id vtpg_of_match[] = {
	{ .compatible = "xlnx,v-tpg-7.0", },
	{ /* end of list */ },
};
MODULE_DEVICE_TABLE(of, vtpg_of_match);

static struct platform_driver vtpg_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table = vtpg_of_match,
	},
	.probe = vtpg_probe,
	.remove = vtpg_remove,
};

static int __init vtpg_init(void)
{	printk("Initialising module\n");
	return(platform_driver_register(&vtpg_driver));
}

static void __exit vtpg_exit(void)
{
	printk("Exiting module\n");
	platform_driver_unregister(&vtpg_driver);
}
//---------------------------------------------------------------------------------------
module_init(vtpg_init);
module_exit(vtpg_exit);

MODULE_AUTHOR("Cleo Joseph");
MODULE_DESCRIPTION("Custom Video Test Pattern Generator IP driver");
MODULE_LICENSE("GPL");
